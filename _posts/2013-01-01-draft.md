---
layout: post
title: Adding digits in Python
---

Given a positive integer, compute the sum of its digits. This very simple task ended up taking me in my first journey through Python's internals.


The first solution that came to my mind was:

{% highlight python %}
def first_way(n):
    stringified_num = str(n)
    ans = 0
    for digit in stringified_num:
        ans += int(digit)
    return ans
{% endhighlight %}

I could make it a one-liner:

{% highlight python %}
def first_way_one_liner(n):
    return sum([int(digit) for digit in str(n)])
{% endhighlight %}

So if I start with the number 1234, I'll first convert it to the string "1234". Then I will look at every character in the string convert it back to an integer and add that. That's ugly, and it sounds so inefficient.


I could get the last digit of an integer doing n % 10. And the next-to-last digit is just the last digit of n/10:[^1]

{% highlight python %}
def second_way(n):
    if n == 0:
        return 0
    return (n % 10) + second_way(n/10)
{% endhighlight %}

Or an iterative version:

{% highlight python %}
def second_way_iterative(n):
    ans = 0
    while n > 0:
        ans += n % 10
        n = n/10
    return ans
{% endhighlight %}

The second way is harder to read, but it's better, right? Python has to know every digit of a number to convert it to a string, so I was duplicating work by looking at every digit again.

### Timing

I decided to experiment calling the 4 functions 100,000 times each [^2] with a 400-digit integer and comparing run times. My theory: there would be no real difference between two functions of the same way, but the second way would be faster then the first. My results:

{% highlight python %}
~$ time python adding_digits_first_way.py

real	0m11.837s
user	0m11.832s
sys	0m0.008s
~$ time python adding_digits_first_way_one_liner.py

real	0m11.898s
user	0m11.905s
sys	0m0.000s
~$ time python adding_digits_second_way.py

real	0m32.952s
user	0m32.968s
sys	0m0.004s
~$ time python adding_digits_second_way_iterative.py

real	0m32.770s
user	0m32.786s
sys	0m0.004s
{% endhighlight %}

Turns out my intuition was right first part, but very wrong about the second.

### Why?

The answer lies in [str(n)](https://github.com/python-git/python/blob/master/Objects/longobject.c#L1294).

Although str(n) does something similar to second_way to get every digit, it is smarter. When n is a long integer (d digits), instead of doing $$d$$ long integer divisions (like second_way) by 10, str(n) does $$d/9$$ long integer divisions by $$10^9$$. Then it converts $$d/9$$ 9-digit numbers into strings, but this operation has way less overhead because 9-digit numbers fit in a 32-bit integer.

Let's apply this optimization to second_way:

{% highlight python %}
def second_way_optimized(n):
    ans = 0
    while n > 0:
        tmp = int(n % 1000000000)
        while tmp > 0:
            ans += tmp % 10
            tmp = tmp / 10
        n = n/1000000000
    return ans
{% endhighlight %}

And time it:

{% highlight python %}
~$ time python adding_digits_second_way_optimized.py

real	0m7.991s
user	0m7.987s
sys	0m0.004s
{% endhighlight %}

That's faster than first_way!

### Conclusion

This experience taught me it's possible for the naive code to be better. Before doing this, if I ever needed to write a function to sum digits, I would ended up with something like second_way and just assume it was better than first_way because it looked smarter.

The next time I need to sum the digits of an integer[^3] I will use the first way. Even though second_way_optimized was faster, I don't think the added complexity is worth it.

[^1]: I spent a ridiculous amount of time deciding if the base case should be n == 0 or n < 10. If you have a strong opinion about it, please tell me!
[^2]: 100,000 was enough to get a stable run time between several different runs.
[^3]: Okay, I never actually needed to add digits, but if it happens, I'm prepared.
