---
layout: post
title: Adding digits in Python
---

Given a positive integer, compute the sum of its digits. This very simple task ended up taking me in my first journey through Python's internals.

The first solution that came to my mind was:

{% highlight python %}
def first_way(n):
    stringfied_num = str(n)
    ans = 0
    for digit in stringfied_num:
        ans += int(digit)
    return ans
{% endhighlight %}

I could make it a one-liner:

{% highlight python %}
def first_way_one_liner(n):
    return sum([int(digit) for digit in str(n)])
{% endhighlight %}

So if I start with the number 1234, I'll first convert it to the string "1234". Then I will look at every character in the string (that it's actually a digit in the number) convert it back to an integer and add that. That's ugly, and it sounds so inefficient.

I could get the last digit of an integer doing n % 10. And the next-to-last digit is just the last digit of n/10:

{% highlight python %}
def second_way_recursive(n):
    if n == 0:
        return 0
    return (n % 10) + second_way(n/10)
{% endhighlight %}

Or an iterative version:

{% highlight python %}
def second_way_iterative(n):
    ans = 0
    while n > 0:
        ans += n % 10
        n = n/10
    return ans
{% endhighlight %}

The second way is harder to read, but it's better, right? Python has to know every digit of a number to convert it to a string, so I was duplicating work by looking at every digit again.

### Timing

I decided to experiment calling the 4 functions a million times each [footnote: one million was enough to get a stable run time between several different runs] with a 400-digits integer and comparing run times. My theory: there would be no real difference between two functions of the same way, but the second way would be faster then the first. My results:

{% highlight shell %}
~$ time python adding_digits_first_way.py

real	0m11.837s
user	0m11.832s
sys	0m0.008s
~$ time python adding_digits_first_way_one_liner.py

real	0m11.898s
user	0m11.905s
sys	0m0.000s
~$ time python adding_digits_second_way.py

real	0m32.952s
user	0m32.968s
sys	0m0.004s
~$ time python adding_digits_second_way_iterative.py

real	0m32.770s
user	0m32.786s
sys	0m0.004s
{% endhighlight %}

Turns out my intuition was right first part, but very wrong about the second.

### Why?
